import { Document, Paragraph, TextRun, HeadingLevel, AlignmentType, Packer } from 'docx';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';

export interface ExportData {
  title: string;
  provider: string;
  model: string;
  prompt: string;
  response: string;
  timestamp: Date;
  tokensUsed?: number;
  cost?: number;
}

/**
 * Export response to Word (.docx) format
 */
export async function exportToWord(data: ExportData): Promise<void> {
  try {
    const doc = new Document({
      sections: [{
        properties: {},
        children: [
          // Title
          new Paragraph({
            text: data.title || 'AI Response Export',
            heading: HeadingLevel.HEADING_1,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
          }),
          
          // Metadata
          new Paragraph({
            text: 'Export Details',
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 200, after: 200 },
          }),
          
          new Paragraph({
            children: [
              new TextRun({ text: 'Provider: ', bold: true }),
              new TextRun({ text: data.provider }),
            ],
            spacing: { after: 100 },
          }),
          
          new Paragraph({
            children: [
              new TextRun({ text: 'Model: ', bold: true }),
              new TextRun({ text: data.model }),
            ],
            spacing: { after: 100 },
          }),
          
          new Paragraph({
            children: [
              new TextRun({ text: 'Date: ', bold: true }),
              new TextRun({ text: data.timestamp.toLocaleString() }),
            ],
            spacing: { after: 100 },
          }),
          
          ...(data.tokensUsed ? [
            new Paragraph({
              children: [
                new TextRun({ text: 'Tokens Used: ', bold: true }),
                new TextRun({ text: data.tokensUsed.toLocaleString() }),
              ],
              spacing: { after: 100 },
            })
          ] : []),
          
          ...(data.cost ? [
            new Paragraph({
              children: [
                new TextRun({ text: 'Cost: ', bold: true }),
                new TextRun({ text: `$${data.cost.toFixed(4)}` }),
              ],
              spacing: { after: 200 },
            })
          ] : []),
          
          // Prompt
          new Paragraph({
            text: 'Your Prompt',
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 400, after: 200 },
          }),
          
          new Paragraph({
            text: data.prompt,
            spacing: { after: 400 },
          }),
          
          // Response
          new Paragraph({
            text: 'AI Response',
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 400, after: 200 },
          }),
          
          ...formatResponseForWord(data.response),
          
          // Footer
          new Paragraph({
            children: [
              new TextRun({
                text: `Generated by OneMindAI on ${new Date().toLocaleString()}`,
                italics: true,
              }),
            ],
            alignment: AlignmentType.CENTER,
            spacing: { before: 600 },
          }),
        ],
      }],
    });
    
    // Generate and download
    const blob = await Packer.toBlob(doc);
    downloadBlob(blob, generateFilename(data, 'docx'));
    
  } catch (error) {
    console.error('Error exporting to Word:', error);
    throw new Error('Failed to export to Word. Please try again.');
  }
}

/**
 * Export response to PDF format
 */
export async function exportToPDF(data: ExportData): Promise<void> {
  try {
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });
    
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const maxWidth = pageWidth - (margin * 2);
    let yPosition = margin;
    
    // Title
    pdf.setFontSize(20);
    pdf.setFont('helvetica', 'bold');
    pdf.text(data.title || 'AI Response Export', pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 15;
    
    // Metadata section
    pdf.setFontSize(14);
    pdf.text('Export Details', margin, yPosition);
    yPosition += 8;
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    
    const metadata = [
      `Provider: ${data.provider}`,
      `Model: ${data.model}`,
      `Date: ${data.timestamp.toLocaleString()}`,
      ...(data.tokensUsed ? [`Tokens Used: ${data.tokensUsed.toLocaleString()}`] : []),
      ...(data.cost ? [`Cost: $${data.cost.toFixed(4)}`] : []),
    ];
    
    metadata.forEach(line => {
      if (yPosition > pageHeight - margin) {
        pdf.addPage();
        yPosition = margin;
      }
      pdf.text(line, margin, yPosition);
      yPosition += 6;
    });
    
    yPosition += 10;
    
    // Prompt section
    if (yPosition > pageHeight - margin - 20) {
      pdf.addPage();
      yPosition = margin;
    }
    
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Your Prompt', margin, yPosition);
    yPosition += 8;
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    const promptLines = pdf.splitTextToSize(data.prompt, maxWidth);
    promptLines.forEach((line: string) => {
      if (yPosition > pageHeight - margin) {
        pdf.addPage();
        yPosition = margin;
      }
      pdf.text(line, margin, yPosition);
      yPosition += 6;
    });
    
    yPosition += 10;
    
    // Response section
    if (yPosition > pageHeight - margin - 20) {
      pdf.addPage();
      yPosition = margin;
    }
    
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('AI Response', margin, yPosition);
    yPosition += 8;
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    
    // Format response (handle markdown-like formatting)
    const responseLines = formatResponseForPDF(data.response, pdf, maxWidth);
    responseLines.forEach((line: string) => {
      if (yPosition > pageHeight - margin) {
        pdf.addPage();
        yPosition = margin;
      }
      pdf.text(line, margin, yPosition);
      yPosition += 6;
    });
    
    // Footer
    const footerText = `Generated by OneMindAI on ${new Date().toLocaleString()}`;
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'italic');
    pdf.text(footerText, pageWidth / 2, pageHeight - 10, { align: 'center' });
    
    // Download
    pdf.save(generateFilename(data, 'pdf'));
    
  } catch (error) {
    console.error('Error exporting to PDF:', error);
    throw new Error('Failed to export to PDF. Please try again.');
  }
}

/**
 * Export response as HTML (for advanced PDF with styling)
 */
export async function exportToStyledPDF(elementId: string, data: ExportData): Promise<void> {
  try {
    const element = document.getElementById(elementId);
    if (!element) {
      throw new Error('Element not found');
    }
    
    // Capture element as canvas
    const canvas = await html2canvas(element, {
      scale: 2,
      useCORS: true,
      logging: false,
    });
    
    const imgData = canvas.toDataURL('image/png');
    const pdf = new jsPDF({
      orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
      unit: 'mm',
      format: 'a4',
    });
    
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const imgWidth = pageWidth - 20;
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    
    let heightLeft = imgHeight;
    let position = 10;
    
    pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;
    
    while (heightLeft > 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }
    
    pdf.save(generateFilename(data, 'pdf'));
    
  } catch (error) {
    console.error('Error exporting styled PDF:', error);
    throw new Error('Failed to export styled PDF. Please try again.');
  }
}

/**
 * Format response text for Word document
 */
function formatResponseForWord(response: string): Paragraph[] {
  const lines = response.split('\n');
  const paragraphs: Paragraph[] = [];
  
  lines.forEach(line => {
    if (line.trim() === '') {
      paragraphs.push(new Paragraph({ text: '', spacing: { after: 100 } }));
    } else if (line.startsWith('# ')) {
      paragraphs.push(new Paragraph({
        text: line.substring(2),
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 200, after: 100 },
      }));
    } else if (line.startsWith('## ')) {
      paragraphs.push(new Paragraph({
        text: line.substring(3),
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 200, after: 100 },
      }));
    } else if (line.startsWith('### ')) {
      paragraphs.push(new Paragraph({
        text: line.substring(4),
        heading: HeadingLevel.HEADING_3,
        spacing: { before: 150, after: 100 },
      }));
    } else if (line.startsWith('- ') || line.startsWith('* ')) {
      paragraphs.push(new Paragraph({
        text: line.substring(2),
        bullet: { level: 0 },
        spacing: { after: 50 },
      }));
    } else if (line.match(/^\d+\. /)) {
      paragraphs.push(new Paragraph({
        text: line.replace(/^\d+\. /, ''),
        numbering: { reference: 'default-numbering', level: 0 },
        spacing: { after: 50 },
      }));
    } else {
      paragraphs.push(new Paragraph({
        text: line,
        spacing: { after: 100 },
      }));
    }
  });
  
  return paragraphs;
}

/**
 * Format response text for PDF
 */
function formatResponseForPDF(response: string, pdf: jsPDF, maxWidth: number): string[] {
  const lines = response.split('\n');
  const formattedLines: string[] = [];
  
  lines.forEach(line => {
    if (line.trim() === '') {
      formattedLines.push('');
    } else {
      const splitLines = pdf.splitTextToSize(line, maxWidth);
      formattedLines.push(...splitLines);
    }
  });
  
  return formattedLines;
}

/**
 * Generate filename for export
 */
function generateFilename(data: ExportData, extension: string): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const provider = data.provider.replace(/[^a-z0-9]/gi, '_');
  const title = (data.title || 'response').replace(/[^a-z0-9]/gi, '_').substring(0, 30);
  
  return `OneMindAI_${provider}_${title}_${timestamp}.${extension}`;
}

/**
 * Download blob as file
 */
function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Export all responses to a single Word document
 */
export async function exportAllToWord(responses: ExportData[]): Promise<void> {
  try {
    const sections = responses.map((data, index) => ({
      properties: {},
      children: [
        new Paragraph({
          text: `Response ${index + 1}: ${data.title || 'Untitled'}`,
          heading: HeadingLevel.HEADING_1,
          spacing: { before: index > 0 ? 600 : 0, after: 400 },
        }),
        
        new Paragraph({
          children: [
            new TextRun({ text: 'Provider: ', bold: true }),
            new TextRun({ text: `${data.provider} (${data.model})` }),
          ],
          spacing: { after: 100 },
        }),
        
        new Paragraph({
          children: [
            new TextRun({ text: 'Date: ', bold: true }),
            new TextRun({ text: data.timestamp.toLocaleString() }),
          ],
          spacing: { after: 200 },
        }),
        
        new Paragraph({
          text: 'Prompt:',
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 200, after: 100 },
        }),
        
        new Paragraph({
          text: data.prompt,
          spacing: { after: 200 },
        }),
        
        new Paragraph({
          text: 'Response:',
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 200, after: 100 },
        }),
        
        ...formatResponseForWord(data.response),
      ],
    }));
    
    const doc = new Document({ sections });
    const blob = await Packer.toBlob(doc);
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    downloadBlob(blob, `OneMindAI_All_Responses_${timestamp}.docx`);
    
  } catch (error) {
    console.error('Error exporting all to Word:', error);
    throw new Error('Failed to export all responses. Please try again.');
  }
}
