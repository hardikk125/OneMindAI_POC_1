import { 
  Document, 
  Paragraph, 
  TextRun, 
  HeadingLevel, 
  AlignmentType, 
  Packer,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  ShadingType,
  ImageRun
} from 'docx';
import * as pdfMakeModule from 'pdfmake/build/pdfmake';
import * as pdfFonts from 'pdfmake/build/vfs_fonts';
import type { TDocumentDefinitions, Content, ContentTable, TableCell as PdfTableCell } from 'pdfmake/interfaces';
import html2canvas from 'html2canvas';

// Initialize pdfmake with fonts
const pdfMake = (pdfMakeModule as any).default || pdfMakeModule;
if (pdfFonts && (pdfFonts as any).pdfMake) {
  pdfMake.vfs = (pdfFonts as any).pdfMake.vfs;
}

export interface ExportData {
  title: string;
  provider: string;
  model: string;
  prompt: string;
  response: string;
  timestamp: Date;
  tokensUsed?: number;
  cost?: number;
  chartImages?: string[];
}

// Color palette for beautiful exports
const COLORS = {
  primary: '#4361ee',
  primaryDark: '#3730a3',
  secondary: '#8b5cf6',
  success: '#10b981',
  warning: '#f59e0b',
  danger: '#ef4444',
  dark: '#1e293b',
  gray: '#64748b',
  lightGray: '#f8fafc',
  white: '#ffffff',
  border: '#e2e8f0'
};

// ============================================
// PDFMAKE - Beautiful PDF Export
// ============================================

/**
 * Export single response to beautiful PDF using pdfmake
 */
export async function exportToPDF(data: ExportData): Promise<void> {
  try {
    const docDefinition = createPdfDocument([data], data.title || 'AI Response Export');
    pdfMake.createPdf(docDefinition).download(generateFilename(data, 'pdf'));
  } catch (error) {
    console.error('Error exporting to PDF:', error);
    throw new Error('Failed to export to PDF. Please try again.');
  }
}

/**
 * Export all responses to a single beautiful PDF
 */
export async function exportAllToPDF(responses: ExportData[]): Promise<void> {
  try {
    console.log('Starting PDF export with', responses.length, 'responses');
    const docDefinition = createPdfDocument(responses, 'Collective Responses');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    
    // Use getBlob for more reliable download
    return new Promise((resolve, reject) => {
      try {
        const pdfDoc = pdfMake.createPdf(docDefinition);
        pdfDoc.getBlob((blob: Blob) => {
          try {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `OneMindAI_Collective_Responses_${timestamp}.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            console.log('PDF exported successfully');
            resolve();
          } catch (downloadError) {
            console.error('Error downloading PDF:', downloadError);
            reject(downloadError);
          }
        });
      } catch (createError) {
        console.error('Error creating PDF:', createError);
        reject(createError);
      }
    });
  } catch (error) {
    console.error('Error exporting all to PDF:', error);
    throw new Error('Failed to export all responses to PDF. Please try again.');
  }
}

/**
 * Create pdfmake document definition
 */
function createPdfDocument(responses: ExportData[], title: string): TDocumentDefinitions {
  const content: Content[] = [];
  
  // Header with gradient-like effect
  content.push({
    table: {
      widths: ['*'],
      body: [[{
        text: title,
        style: 'mainTitle',
        fillColor: COLORS.primary,
        color: COLORS.white,
        margin: [20, 15, 20, 15]
      }]]
    },
    layout: 'noBorders',
    margin: [0, 0, 0, 5]
  });
  
  // Subtitle with metadata and Formula2GX branding on same line
  content.push({
    text: `Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs ‚Ä¢ ${new Date().toLocaleDateString()} ‚Ä¢ ${responses.length} Engine${responses.length !== 1 ? 's' : ''}`,
    style: 'subtitle',
    margin: [0, 0, 0, 20]
  });
  
  // Add each response
  responses.forEach((data, index) => {
    // Engine header card
    content.push({
      table: {
        widths: ['*', 'auto'],
        body: [[
          {
            stack: [
              { text: data.provider.toUpperCase(), style: 'providerName' },
              { text: data.model, style: 'modelName' }
            ],
            fillColor: COLORS.lightGray,
            margin: [15, 12, 15, 12]
          },
          {
            text: `${index + 1}/${responses.length}`,
            style: 'engineCount',
            fillColor: COLORS.lightGray,
            margin: [15, 15, 15, 15]
          }
        ]]
      },
      layout: {
        hLineWidth: () => 0,
        vLineWidth: () => 0,
        paddingLeft: () => 0,
        paddingRight: () => 0
      },
      margin: [0, index > 0 ? 25 : 0, 0, 10]
    });
    
    // Prompt section
    if (data.prompt) {
      content.push({
        table: {
          widths: ['*'],
          body: [[{
            stack: [
              { text: 'PROMPT', style: 'sectionLabel' },
              { text: data.prompt.length > 300 ? data.prompt.substring(0, 300) + '...' : data.prompt, style: 'promptText' }
            ],
            fillColor: '#eff6ff',
            margin: [12, 10, 12, 10]
          }]]
        },
        layout: {
          hLineWidth: () => 1,
          vLineWidth: () => 0,
          hLineColor: () => COLORS.primary,
          paddingLeft: () => 0,
          paddingRight: () => 0
        },
        margin: [0, 0, 0, 15]
      });
    }
    
    // Response content - parse markdown (clean symbols)
    const responseContent = parseMarkdownToPdfContent(cleanMarkdownSymbols(data.response));
    content.push(...responseContent);
    
    // Add chart images if available
    if (data.chartImages && data.chartImages.length > 0) {
      content.push({
        text: 'Charts & Visualizations',
        style: 'h2',
        margin: [0, 15, 0, 10]
      });
      
      data.chartImages.forEach((chartBase64, chartIndex) => {
        try {
          content.push({
            image: chartBase64,
            width: 450,
            alignment: 'center',
            margin: [0, 10, 0, 15]
          });
        } catch (imgError) {
          console.error('Failed to add chart image to PDF:', imgError);
        }
      });
    }
    
    // Metadata footer
    const metaItems: string[] = [];
    if (data.tokensUsed) metaItems.push(`üìä ${data.tokensUsed.toLocaleString()} tokens`);
    if (data.cost) metaItems.push(`üí∞ $${data.cost.toFixed(4)}`);
    metaItems.push(`üïê ${data.timestamp.toLocaleTimeString()}`);
    
    content.push({
      text: metaItems.join('  ‚Ä¢  '),
      style: 'metadata',
      margin: [0, 15, 0, 0]
    });
    
    // Separator between responses
    if (index < responses.length - 1) {
      content.push({
        canvas: [{
          type: 'line',
          x1: 50, y1: 0,
          x2: 465, y2: 0,
          lineWidth: 1,
          lineColor: COLORS.border,
          dash: { length: 5, space: 3 }
        }],
        margin: [0, 20, 0, 10]
      });
    }
  });
  
  return {
    content,
    pageSize: 'A4',
    pageMargins: [40, 60, 40, 60],
    defaultStyle: {
      font: 'Roboto',
      fontSize: 10,
      lineHeight: 1.4
    },
    styles: {
      mainTitle: {
        fontSize: 22,
        bold: true,
        color: COLORS.white
      },
      subtitle: {
        fontSize: 10,
        italics: true,
        color: COLORS.gray
      },
      providerName: {
        fontSize: 14,
        bold: true,
        color: COLORS.primary
      },
      modelName: {
        fontSize: 11,
        color: COLORS.gray
      },
      engineCount: {
        fontSize: 12,
        bold: true,
        color: COLORS.primary
      },
      sectionLabel: {
        fontSize: 9,
        bold: true,
        color: COLORS.primary,
        margin: [0, 0, 0, 5]
      },
      promptText: {
        fontSize: 10,
        color: COLORS.dark
      },
      h1: {
        fontSize: 16,
        bold: true,
        color: COLORS.primaryDark,
        margin: [0, 15, 0, 8]
      },
      h2: {
        fontSize: 14,
        bold: true,
        color: COLORS.primaryDark,
        margin: [0, 12, 0, 6]
      },
      h3: {
        fontSize: 12,
        bold: true,
        color: COLORS.primaryDark,
        margin: [0, 10, 0, 5]
      },
      paragraph: {
        fontSize: 10,
        color: COLORS.dark,
        margin: [0, 0, 0, 8]
      },
      listItem: {
        fontSize: 10,
        color: COLORS.dark,
        margin: [0, 2, 0, 2]
      },
      codeBlock: {
        fontSize: 9,
        font: 'Courier',
        background: COLORS.dark,
        color: '#e2e8f0',
        margin: [0, 8, 0, 8]
      },
      inlineCode: {
        fontSize: 9,
        font: 'Courier',
        background: COLORS.lightGray
      },
      tableHeader: {
        fontSize: 10,
        bold: true,
        color: COLORS.white,
        fillColor: COLORS.primary
      },
      tableCell: {
        fontSize: 9,
        color: COLORS.dark
      },
      metadata: {
        fontSize: 9,
        color: COLORS.gray
      }
    },
    footer: (currentPage: number, pageCount: number) => ({
      columns: [
        { text: 'Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs', style: 'metadata', alignment: 'left', margin: [40, 0, 0, 0] },
        { text: `Page ${currentPage} of ${pageCount}`, style: 'metadata', alignment: 'right', margin: [0, 0, 40, 0] }
      ],
      margin: [0, 20, 0, 0]
    })
  };
}

/**
 * Parse markdown content to pdfmake content array
 */
function parseMarkdownToPdfContent(markdown: string): Content[] {
  const content: Content[] = [];
  const lines = markdown.split('\n');
  let inCodeBlock = false;
  let codeBlockContent = '';
  let codeBlockLang = '';
  let inTable = false;
  let tableRows: string[][] = [];
  let listItems: string[] = [];
  let inList = false;
  let inHeading = false;
  
  const flushList = () => {
    if (listItems.length > 0) {
      content.push({
        ul: listItems.map(item => ({ text: item, style: 'listItem' })),
        margin: [15, 5, 0, 10]
      });
      listItems = [];
      inList = false;
    }
  };
  
  const flushTable = () => {
    if (tableRows.length > 0) {
      const headerRow = tableRows[0];
      const dataRows = tableRows.slice(2); // Skip separator row
      
      const tableBody: PdfTableCell[][] = [
        headerRow.map(cell => ({
          text: cell.trim(),
          style: 'tableHeader',
          fillColor: COLORS.primary,
          color: COLORS.white,
          margin: [8, 6, 8, 6]
        }))
      ];
      
      dataRows.forEach((row, idx) => {
        tableBody.push(row.map(cell => ({
          text: cell.trim(),
          style: 'tableCell',
          fillColor: idx % 2 === 0 ? COLORS.white : COLORS.lightGray,
          margin: [8, 5, 8, 5]
        })));
      });
      
      content.push({
        table: {
          headerRows: 1,
          widths: headerRow.map(() => '*'),
          body: tableBody
        },
        layout: {
          hLineWidth: () => 0.5,
          vLineWidth: () => 0.5,
          hLineColor: () => COLORS.border,
          vLineColor: () => COLORS.border
        },
        margin: [0, 10, 0, 15]
      } as ContentTable);
      
      tableRows = [];
      inTable = false;
    }
  };
  
  lines.forEach((line) => {
    const trimmed = line.trim();
    
    // Code block handling
    if (trimmed.startsWith('```')) {
      if (inCodeBlock) {
        // End code block
        content.push({
          table: {
            widths: ['*'],
            body: [[{
              text: codeBlockContent.trim(),
              font: 'Courier',
              fontSize: 9,
              color: '#e2e8f0',
              fillColor: COLORS.dark,
              margin: [12, 10, 12, 10]
            }]]
          },
          layout: 'noBorders',
          margin: [0, 8, 0, 12]
        });
        codeBlockContent = '';
        inCodeBlock = false;
      } else {
        flushList();
        flushTable();
        codeBlockLang = trimmed.substring(3);
        inCodeBlock = true;
      }
      return;
    }
    
    if (inCodeBlock) {
      codeBlockContent += line + '\n';
      return;
    }
    
    // Table handling
    if (trimmed.match(/^\|.*\|$/)) {
      flushList();
      if (!inTable) inTable = true;
      const cells = line.split('|').filter(c => c.trim() !== '');
      tableRows.push(cells);
      return;
    } else if (inTable && trimmed === '') {
      flushTable();
      return;
    }
    
    // Headings - Handle both # and *** style headings
    if (trimmed.startsWith('### ')) {
      flushList();
      flushTable();
      content.push({ text: line.substring(4).trim(), style: 'h3' });
      return;
    }
    if (trimmed.startsWith('## ')) {
      flushList();
      flushTable();
      content.push({ text: line.substring(3).trim(), style: 'h2' });
      return;
    }
    if (trimmed.startsWith('# ')) {
      flushList();
      flushTable();
      content.push({ text: line.substring(2).trim(), style: 'h1' });
      return;
    }
    
    // Handle asterisk-based headings (*** Title ***)
    if (trimmed.match(/^\*{3}(.+?)\*{3}$/)) {
      flushList();
      flushTable();
      const match = trimmed.match(/^\*{3}(.+?)\*{3}$/);
      if (match) {
        content.push({ text: match[1].trim(), style: 'h1' });
      }
      return;
    }
    if (trimmed.match(/^\*{2}(.+?)\*{2}$/)) {
      flushList();
      flushTable();
      const match = trimmed.match(/^\*{2}(.+?)\*{2}$/);
      if (match) {
        content.push({ text: match[1].trim(), style: 'h2' });
      }
      return;
    }
    if (trimmed.match(/^\*(.+?)\*$/)) {
      flushList();
      flushTable();
      const match = trimmed.match(/^\*(.+?)\*$/);
      if (match) {
        content.push({ text: match[1].trim(), style: 'h3' });
      }
      return;
    }
    
    // List items
    if (line.match(/^[\s]*[-*+]\s+(.+)/) || line.match(/^[\s]*\d+\.\s+(.+)/)) {
      flushTable();
      inList = true;
      const match = line.match(/^[\s]*[-*+\d.]+\s+(.+)/);
      if (match) {
        listItems.push(cleanMarkdownSymbols(match[1]));
      }
      return;
    }
    
    // Empty line
    if (line.trim() === '') {
      flushList();
      flushTable();
      return;
    }
    
    // Regular paragraph
    flushList();
    flushTable();
    content.push({ 
      text: cleanMarkdownSymbols(line), 
      style: 'paragraph' 
    });
  });
  
  // Flush remaining content
  flushList();
  flushTable();
  
  return content;
}

/**
 * Clean all markdown symbols from text
 */
function cleanMarkdownSymbols(text: string): string {
  return text
    // Remove heading markers
    .replace(/^#{1,6}\s+/gm, '')
    // Remove bold markers
    .replace(/\*\*(.+?)\*\*/g, '$1')
    .replace(/__(.+?)__/g, '$1')
    // Remove italic markers
    .replace(/\*(.+?)\*/g, '$1')
    .replace(/_(.+?)_/g, '$1')
    // Remove code markers
    .replace(/`(.+?)`/g, '$1')
    // Remove asterisk heading markers
    .replace(/^\*{3}(.+?)\*{3}$/gm, '$1')
    .replace(/^\*{2}(.+?)\*{2}$/gm, '$1')
    .replace(/^\*(.+?)\*$/gm, '$1')
    // Remove horizontal rules
    .replace(/^[-*_]{3,}$/gm, '')
    // Remove list markers but keep content
    .replace(/^[\s]*[-*+]\s+/gm, '‚Ä¢ ')
    .replace(/^[\s]*\d+\.\s+/gm, '')
    // Remove blockquote markers
    .replace(/^>\s+/gm, '')
    // Remove link syntax but keep text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    // Remove image syntax
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')
    // Clean up extra whitespace
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

// ============================================
// DOCX - Enhanced Word Export
// ============================================

/**
 * Export single response to Word with beautiful formatting
 */
export async function exportToWord(data: ExportData): Promise<void> {
  try {
    const doc = createWordDocument([data], data.title || 'AI Response Export');
    const blob = await Packer.toBlob(doc);
    downloadBlob(blob, generateFilename(data, 'docx'));
  } catch (error) {
    console.error('Error exporting to Word:', error);
    throw new Error('Failed to export to Word. Please try again.');
  }
}

/**
 * Export all responses to a single Word document
 */
export async function exportAllToWord(responses: ExportData[]): Promise<void> {
  try {
    const doc = createWordDocument(responses, 'Collective Responses');
    const blob = await Packer.toBlob(doc);
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    downloadBlob(blob, `OneMindAI_Collective_Responses_${timestamp}.docx`);
  } catch (error) {
    console.error('Error exporting all to Word:', error);
    throw new Error('Failed to export all responses. Please try again.');
  }
}

/**
 * Create Word document with beautiful formatting
 */
function createWordDocument(responses: ExportData[], title: string): Document {
  const children: (Paragraph | Table)[] = [];
  
  // Title with blue underline
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: title,
          bold: true,
          size: 48,
          color: '1e293b'
        })
      ],
      spacing: { after: 100 },
      border: {
        bottom: { color: '4361ee', size: 12, style: BorderStyle.SINGLE }
      }
    })
  );
  
  // Subtitle with Formula2GX branding on same line
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs ‚Ä¢ ${new Date().toLocaleDateString()} ‚Ä¢ ${responses.length} Engine${responses.length !== 1 ? 's' : ''}`,
          italics: true,
          size: 20,
          color: '64748b'
        })
      ],
      spacing: { after: 400 }
    })
  );
  
  // Add each response
  responses.forEach((data, index) => {
    // Engine header
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: data.provider.toUpperCase(),
            bold: true,
            size: 28,
            color: '4361ee'
          }),
          new TextRun({
            text: ` (${data.model})`,
            size: 24,
            color: '64748b'
          }),
          new TextRun({
            text: `  ${index + 1}/${responses.length}`,
            bold: true,
            size: 22,
            color: '4361ee'
          })
        ],
        spacing: { before: index > 0 ? 400 : 200, after: 100 },
        border: {
          bottom: { color: '4361ee', size: 6, style: BorderStyle.SINGLE }
        }
      })
    );
    
    // Prompt section
    if (data.prompt) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: 'PROMPT: ', bold: true, size: 18, color: '4361ee' }),
            new TextRun({ 
              text: data.prompt.length > 200 ? data.prompt.substring(0, 200) + '...' : data.prompt, 
              size: 20, 
              color: '374151' 
            })
          ],
          spacing: { before: 150, after: 200 },
          shading: { type: ShadingType.SOLID, color: 'eff6ff' }
        })
      );
    }
    
    // Response content - parse markdown (clean symbols)
    const responseElements = parseMarkdownToDocx(cleanMarkdownSymbols(data.response));
    children.push(...responseElements);
    
    // Add chart images if available
    if (data.chartImages && data.chartImages.length > 0) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Charts & Visualizations',
              bold: true,
              size: 28,
              color: '3730a3'
            })
          ],
          spacing: { before: 300, after: 150 }
        })
      );
      
      // Add chart images to Word document
      for (let chartIndex = 0; chartIndex < data.chartImages.length; chartIndex++) {
        const chartBase64 = data.chartImages[chartIndex];
        try {
          // Extract base64 data (without the data URL prefix)
          const base64Data = chartBase64.replace(/^data:image\/\w+;base64,/, '');
          
          // Detect image type from data URL
          const isPng = chartBase64.includes('image/png');
          const isJpeg = chartBase64.includes('image/jpeg') || chartBase64.includes('image/jpg');
          const imageType = isPng ? 'png' : isJpeg ? 'jpg' : 'png';
          
          console.log(`Processing chart ${chartIndex + 1}: type=${imageType}, base64 length=${base64Data.length}`);
          
          // For docx v9.x - pass base64 string directly as data
          const imageRun = new ImageRun({
            type: imageType,
            data: base64Data,  // Pass base64 string directly
            transformation: {
              width: 500,
              height: 300
            }
          });
          
          children.push(
            new Paragraph({
              children: [imageRun],
              alignment: AlignmentType.CENTER,
              spacing: { before: 200, after: 300 }
            })
          );
          
          console.log(`Chart ${chartIndex + 1} successfully added to Word document`);
        } catch (imgError) {
          console.error('Failed to add chart image to Word:', imgError);
          // Show error in document
          children.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: `[Chart ${chartIndex + 1} - Error: ${imgError instanceof Error ? imgError.message : 'Unknown error'}]`,
                  italics: true,
                  color: 'dc2626',
                  size: 20
                })
              ],
              spacing: { before: 100, after: 100 }
            })
          );
        }
      }
    }
    
    // Metadata
    const metaItems: string[] = [];
    if (data.tokensUsed) metaItems.push(`üìä ${data.tokensUsed.toLocaleString()} tokens`);
    if (data.cost) metaItems.push(`üí∞ $${data.cost.toFixed(4)}`);
    metaItems.push(`üïê ${data.timestamp.toLocaleTimeString()}`);
    
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: metaItems.join('  ‚Ä¢  '),
            size: 18,
            color: '64748b'
          })
        ],
        spacing: { before: 200, after: 100 }
      })
    );
    
    // Separator
    if (index < responses.length - 1) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: '‚îÄ'.repeat(60),
              color: 'e2e8f0'
            })
          ],
          spacing: { before: 200, after: 200 },
          alignment: AlignmentType.CENTER
        })
      );
    }
  });
  
  // Footer
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Exported from OneMindAI on ${new Date().toLocaleString()}`,
          italics: true,
          size: 18,
          color: '9ca3af'
        })
      ],
      spacing: { before: 400 },
      alignment: AlignmentType.CENTER
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: 'powered by Formula2GX Digital Advanced Incubation Labs',
          italics: true,
          size: 16,
          color: '6b7280'
        })
      ],
      spacing: { before: 100 },
      alignment: AlignmentType.CENTER
    })
  );
  
  return new Document({
    sections: [{
      properties: {},
      children
    }]
  });
}

/**
 * Parse markdown to docx elements with proper formatting
 */
function parseMarkdownToDocx(markdown: string): (Paragraph | Table)[] {
  const elements: (Paragraph | Table)[] = [];
  const lines = markdown.split('\n');
  let inCodeBlock = false;
  let codeBlockContent = '';
  let inTable = false;
  let tableRows: string[][] = [];
  let listItems: { text: string; level: number }[] = [];
  
  const flushList = () => {
    if (listItems.length > 0) {
      listItems.forEach(item => {
        elements.push(
          new Paragraph({
            children: parseInlineFormatting(item.text),
            bullet: { level: item.level },
            spacing: { after: 50 }
          })
        );
      });
      listItems = [];
    }
  };
  
  const flushTable = () => {
    if (tableRows.length >= 2) {
      const headerRow = tableRows[0];
      const dataRows = tableRows.slice(2); // Skip separator
      
      const table = new Table({
        width: { size: 100, type: WidthType.PERCENTAGE },
        rows: [
          // Header row
          new TableRow({
            children: headerRow.map(cell => 
              new TableCell({
                children: [new Paragraph({
                  children: [new TextRun({ text: cell.trim(), bold: true, color: 'ffffff', size: 20 })],
                  alignment: AlignmentType.CENTER
                })],
                shading: { type: ShadingType.SOLID, color: '4361ee' },
                margins: { top: 100, bottom: 100, left: 100, right: 100 }
              })
            )
          }),
          // Data rows
          ...dataRows.map((row, idx) => 
            new TableRow({
              children: row.map(cell =>
                new TableCell({
                  children: [new Paragraph({
                    children: [new TextRun({ text: cell.trim(), size: 20 })]
                  })],
                  shading: { type: ShadingType.SOLID, color: idx % 2 === 0 ? 'ffffff' : 'f8fafc' },
                  margins: { top: 80, bottom: 80, left: 100, right: 100 }
                })
              )
            })
          )
        ]
      });
      
      elements.push(table);
      elements.push(new Paragraph({ text: '', spacing: { after: 200 } }));
      tableRows = [];
      inTable = false;
    }
  };
  
  lines.forEach((line) => {
    // Code block
    if (line.trim().startsWith('```')) {
      if (inCodeBlock) {
        // End code block - create styled paragraph
        elements.push(
          new Paragraph({
            children: [
              new TextRun({
                text: codeBlockContent.trim(),
                font: 'Consolas',
                size: 18,
                color: 'e2e8f0'
              })
            ],
            shading: { type: ShadingType.SOLID, color: '1e293b' },
            spacing: { before: 100, after: 200 }
          })
        );
        codeBlockContent = '';
        inCodeBlock = false;
      } else {
        flushList();
        flushTable();
        inCodeBlock = true;
      }
      return;
    }
    
    if (inCodeBlock) {
      codeBlockContent += line + '\n';
      return;
    }
    
    // Table
    if (line.trim().match(/^\|.*\|$/)) {
      flushList();
      if (!inTable) inTable = true;
      const cells = line.split('|').filter(c => c !== '');
      tableRows.push(cells);
      return;
    } else if (inTable && line.trim() === '') {
      flushTable();
      return;
    }
    
    // Headings - Handle both # and *** style headings
    if (line.startsWith('### ')) {
      flushList();
      flushTable();
      elements.push(new Paragraph({
        children: [new TextRun({ text: line.substring(4).trim(), bold: true, size: 24, color: '3730a3' })],
        heading: HeadingLevel.HEADING_3,
        spacing: { before: 200, after: 100 }
      }));
      return;
    }
    if (line.startsWith('## ')) {
      flushList();
      flushTable();
      elements.push(new Paragraph({
        children: [new TextRun({ text: line.substring(3).trim(), bold: true, size: 28, color: '3730a3' })],
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 250, after: 120 }
      }));
      return;
    }
    if (line.startsWith('# ')) {
      flushList();
      flushTable();
      elements.push(new Paragraph({
        children: [new TextRun({ text: line.substring(2).trim(), bold: true, size: 32, color: '3730a3' })],
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 300, after: 150 }
      }));
      return;
    }
    
    // Handle asterisk-based headings (*** Title ***)
    const trimmed = line.trim();
    if (trimmed.match(/^\*{3}(.+?)\*{3}$/)) {
      flushList();
      flushTable();
      const match = trimmed.match(/^\*{3}(.+?)\*{3}$/);
      if (match) {
        elements.push(new Paragraph({
          children: [new TextRun({ text: match[1].trim(), bold: true, size: 32, color: '3730a3' })],
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 300, after: 150 }
        }));
      }
      return;
    }
    if (trimmed.match(/^\*{2}(.+?)\*{2}$/)) {
      flushList();
      flushTable();
      const match = trimmed.match(/^\*{2}(.+?)\*{2}$/);
      if (match) {
        elements.push(new Paragraph({
          children: [new TextRun({ text: match[1].trim(), bold: true, size: 28, color: '3730a3' })],
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 250, after: 120 }
        }));
      }
      return;
    }
    if (trimmed.match(/^\*(.+?)\*$/)) {
      flushList();
      flushTable();
      const match = trimmed.match(/^\*(.+?)\*$/);
      if (match) {
        elements.push(new Paragraph({
          children: [new TextRun({ text: match[1].trim(), bold: true, size: 24, color: '3730a3' })],
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 200, after: 100 }
        }));
      }
      return;
    }
    
    // List items
    const bulletMatch = line.match(/^(\s*)[-*+]\s+(.+)/);
    const numberMatch = line.match(/^(\s*)\d+\.\s+(.+)/);
    if (bulletMatch || numberMatch) {
      flushTable();
      const match = bulletMatch || numberMatch;
      if (match) {
        const indent = match[1].length;
        const level = Math.floor(indent / 2);
        listItems.push({ text: match[2], level });
      }
      return;
    }
    
    // Empty line
    if (line.trim() === '') {
      flushList();
      flushTable();
      return;
    }
    
    // Regular paragraph
    flushList();
    flushTable();
    elements.push(new Paragraph({
      children: parseInlineFormatting(line),
      spacing: { after: 120 }
    }));
  });
  
  flushList();
  flushTable();
  
  return elements;
}

/**
 * Parse inline markdown formatting (bold, italic, code)
 */
function parseInlineFormatting(text: string): TextRun[] {
  const runs: TextRun[] = [];
  let remaining = text;
  
  // Simple approach - just handle the text with basic formatting detection
  const boldRegex = /\*\*(.+?)\*\*/g;
  const italicRegex = /\*(.+?)\*/g;
  const codeRegex = /`(.+?)`/g;
  
  // For simplicity, strip formatting markers and return plain text
  // A more complex implementation would parse and apply styles
  const cleanText = remaining
    .replace(boldRegex, '$1')
    .replace(italicRegex, '$1')
    .replace(codeRegex, '$1')
    .replace(/^\*{3}(.+?)\*{3}$/g, '$1') // Remove *** heading markers
    .replace(/^\*{2}(.+?)\*{2}$/g, '$1') // Remove ** heading markers
    .replace(/^\*(.+?)\*$/g, '$1');   // Remove * heading markers
  
  runs.push(new TextRun({ text: cleanText, size: 22 }));
  
  return runs;
}

// ============================================
// Utility Functions
// ============================================

/**
 * Export response as HTML (for advanced PDF with styling)
 */
export async function exportToStyledPDF(elementId: string, data: ExportData): Promise<void> {
  try {
    const element = document.getElementById(elementId);
    if (!element) {
      throw new Error('Element not found');
    }
    
    const canvas = await html2canvas(element, {
      scale: 2,
      useCORS: true,
      logging: false,
    });
    
    const imgData = canvas.toDataURL('image/png');
    const docDefinition: TDocumentDefinitions = {
      content: [{
        image: imgData,
        width: 515
      }],
      pageSize: 'A4',
      pageMargins: [40, 40, 40, 40]
    };
    
    pdfMake.createPdf(docDefinition).download(generateFilename(data, 'pdf'));
  } catch (error) {
    console.error('Error exporting styled PDF:', error);
    throw new Error('Failed to export styled PDF. Please try again.');
  }
}

/**
 * Generate filename for export
 */
function generateFilename(data: ExportData, extension: string): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const provider = data.provider.replace(/[^a-z0-9]/gi, '_');
  const title = (data.title || 'response').replace(/[^a-z0-9]/gi, '_').substring(0, 30);
  return `OneMindAI_${provider}_${title}_${timestamp}.${extension}`;
}

/**
 * Download blob as file
 */
function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Copy all responses to clipboard with beautiful HTML formatting
 */
export async function copyAllToClipboard(dataArray: ExportData[]): Promise<void> {
  try {
    const totalResponses = dataArray.length;
    
    let html = `
      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto;">
        <div style="text-align: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 3px solid #3b82f6;">
          <h1 style="color: #1e40af; margin: 0 0 8px 0; font-size: 28px;">Collective Responses</h1>
          <p style="color: #6b7280; margin: 0; font-size: 14px;">
            Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs ‚Ä¢ ${new Date().toLocaleDateString()} ‚Ä¢ ${totalResponses} Engine${totalResponses > 1 ? 's' : ''}
          </p>
        </div>
    `;
    
    dataArray.forEach((data, index) => {
      html += `
        <div style="margin-bottom: 32px; padding: 20px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #3b82f6;">
            <div>
              <span style="background: linear-gradient(135deg, #3b82f6, #8b5cf6); color: white; padding: 6px 14px; border-radius: 8px; font-weight: 600; font-size: 14px;">
                ${data.provider.toUpperCase()}
              </span>
              <span style="margin-left: 12px; color: #374151; font-weight: 600; font-size: 16px;">${data.model}</span>
            </div>
            <span style="color: #6366f1; font-weight: 600; font-size: 14px;">${index + 1}/${totalResponses}</span>
          </div>
          <div style="color: #1f2937; font-size: 14px; line-height: 1.7;">
            ${formatResponseAsHtml(cleanMarkdownSymbols(data.response))}
          </div>
        </div>
      `;
      
      if (index < dataArray.length - 1) {
        html += `<hr style="border: none; border-top: 2px dashed #cbd5e1; margin: 24px 0;">`;
      }
    });
    
    html += `
        <div style="text-align: center; padding-top: 16px; border-top: 1px solid #e2e8f0; color: #9ca3af; font-size: 12px;">
          Exported from OneMindAI ‚Ä¢ ${new Date().toLocaleString()}<br>
          powered by Formula2GX Digital Advanced Incubation Labs
        </div>
      </div>
    `;
    
    let plainText = `COLLECTIVE RESPONSES\n`;
    plainText += `Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs ‚Ä¢ ${new Date().toLocaleString()} ‚Ä¢ ${totalResponses} Engine${totalResponses > 1 ? 's' : ''}\n`;
    plainText += `${'='.repeat(60)}\n\n`;
    
    dataArray.forEach((data, index) => {
      plainText += `[${index + 1}/${totalResponses}] ${data.provider.toUpperCase()} - ${data.model}\n`;
      plainText += `${'-'.repeat(40)}\n`;
      plainText += `Response:\n${cleanMarkdownSymbols(data.response)}\n\n`;
      if (index < dataArray.length - 1) {
        plainText += `${'‚îÄ'.repeat(60)}\n\n`;
      }
    });
    
    // Add Formula2GX branding to plain text
    plainText += `\n${'='.repeat(60)}\n`;
    plainText += `Exported from OneMindAI ‚Ä¢ ${new Date().toLocaleString()}\n`;
    plainText += `powered by Formula2GX Digital Advanced Incubation Labs\n`;
    
    const blob = new Blob([html], { type: 'text/html' });
    const textBlob = new Blob([plainText], { type: 'text/plain' });
    
    try {
      await navigator.clipboard.write([
        new ClipboardItem({
          'text/html': blob,
          'text/plain': textBlob
        })
      ]);
    } catch (e) {
      await navigator.clipboard.writeText(plainText);
    }
  } catch (error) {
    console.error('Error copying to clipboard:', error);
    throw new Error('Failed to copy responses to clipboard. Please try again.');
  }
}

/**
 * Copy a single response to clipboard with beautiful Word-style formatting
 */
export async function copyToClipboard(data: ExportData): Promise<void> {
  try {
    const html = `
      <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto;">
        <div style="text-align: center; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 3px solid #3b82f6;">
          <h1 style="color: #1e40af; margin: 0 0 8px 0; font-size: 28px;">${data.title}</h1>
          <p style="color: #6b7280; margin: 0; font-size: 14px;">
            Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs ‚Ä¢ ${new Date().toLocaleDateString()}
          </p>
        </div>
        
        <div style="margin-bottom: 24px; padding: 20px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0;">
          <div style="display: flex; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #3b82f6;">
            <span style="background: linear-gradient(135deg, #3b82f6, #8b5cf6); color: white; padding: 6px 14px; border-radius: 8px; font-weight: 600; font-size: 14px;">
              ${data.provider.toUpperCase()}
            </span>
            <span style="margin-left: 12px; color: #374151; font-weight: 600; font-size: 16px;">${data.model}</span>
          </div>
          <div style="color: #1f2937; font-size: 14px; line-height: 1.7;">
            ${formatResponseAsHtml(cleanMarkdownSymbols(data.response))}
          </div>
          ${data.tokensUsed || data.cost ? `
          <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #e2e8f0; display: flex; gap: 16px; font-size: 12px; color: #6b7280;">
            ${data.tokensUsed ? `<span>üìä ${data.tokensUsed.toLocaleString()} tokens</span>` : ''}
            ${data.cost ? `<span>üí∞ $${data.cost.toFixed(4)}</span>` : ''}
          </div>
          ` : ''}
        </div>
        
        <div style="text-align: center; padding-top: 16px; border-top: 1px solid #e2e8f0; color: #9ca3af; font-size: 12px;">
          Exported from OneMindAI ‚Ä¢ ${new Date().toLocaleString()}<br>
          powered by Formula2GX Digital Advanced Incubation Labs
        </div>
      </div>
    `;
    
    let plainText = `${data.title.toUpperCase()}\n`;
    plainText += `Generated by OneMindAI - powered by Formula2GX Digital Advanced Incubation Labs ‚Ä¢ ${new Date().toLocaleString()}\n`;
    plainText += `${'='.repeat(60)}\n\n`;
    plainText += `${data.provider.toUpperCase()} - ${data.model}\n`;
    plainText += `${'-'.repeat(40)}\n`;
    plainText += `${cleanMarkdownSymbols(data.response)}\n\n`;
    if (data.tokensUsed || data.cost) {
      plainText += `${'-'.repeat(40)}\n`;
      if (data.tokensUsed) plainText += `üìä ${data.tokensUsed.toLocaleString()} tokens\n`;
      if (data.cost) plainText += `üí∞ $${data.cost.toFixed(4)}\n`;
    }
    plainText += `\n${'='.repeat(60)}\n`;
    plainText += `Exported from OneMindAI ‚Ä¢ ${new Date().toLocaleString()}\n`;
    plainText += `powered by Formula2GX Digital Advanced Incubation Labs\n`;
    
    const blob = new Blob([html], { type: 'text/html' });
    const textBlob = new Blob([plainText], { type: 'text/plain' });
    
    try {
      await navigator.clipboard.write([
        new ClipboardItem({
          'text/html': blob,
          'text/plain': textBlob
        })
      ]);
    } catch (e) {
      await navigator.clipboard.writeText(plainText);
    }
  } catch (error) {
    console.error('Error copying to clipboard:', error);
    throw new Error('Failed to copy response to clipboard. Please try again.');
  }
}

/**
 * Format response content as beautiful HTML
 */
function formatResponseAsHtml(response: string): string {
  let html = response;
  
  // Code blocks
  const codeBlocks: string[] = [];
  html = html.replace(/```([^\n]*)\n([\s\S]*?)```/g, (match, lang, code) => {
    const placeholder = `___CODE_BLOCK_${codeBlocks.length}___`;
    codeBlocks.push(`
      <pre style="background: #1e293b; color: #e2e8f0; padding: 16px; border-radius: 8px; overflow-x: auto; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; line-height: 1.5; margin: 12px 0;">
        <code>${escapeHtml(code.trim())}</code>
      </pre>
    `);
    return placeholder;
  });
  
  // Inline code
  const inlineCodes: string[] = [];
  html = html.replace(/`([^`]+)`/g, (match, code) => {
    const placeholder = `___INLINE_CODE_${inlineCodes.length}___`;
    inlineCodes.push(`<code style="background: #f1f5f9; color: #0f172a; padding: 2px 6px; border-radius: 4px; font-family: 'Consolas', monospace; font-size: 13px;">${escapeHtml(code)}</code>`);
    return placeholder;
  });
  
  // Tables
  const tableRegex = /(\|[^\n]+\|\n\|[-:\s|]+\|\n(?:\|[^\n]*\|\n?)*)/g;
  html = html.replace(tableRegex, (match) => {
    const lines = match.trim().split('\n');
    if (lines.length < 3) return match;
    
    const headerRow = lines[0];
    const dataRows = lines.slice(2);
    const headers = headerRow.split('|').map(h => h.trim()).filter(h => h);
    
    let tableHtml = `
      <table style="width: 100%; border-collapse: collapse; margin: 16px 0; font-size: 14px; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
        <thead>
          <tr style="background: linear-gradient(135deg, #3b82f6, #1d4ed8);">
            ${headers.map(h => `<th style="padding: 12px 16px; text-align: left; color: white; font-weight: 600; border: 1px solid #2563eb;">${escapeHtml(h)}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
    `;
    
    dataRows.forEach((row, rowIndex) => {
      const cells = row.split('|').map(c => c.trim()).filter(c => c);
      const bgColor = rowIndex % 2 === 0 ? '#f8fafc' : '#ffffff';
      tableHtml += `
        <tr style="background: ${bgColor};">
          ${cells.map(c => `<td style="padding: 10px 16px; border: 1px solid #e2e8f0; color: #374151;">${escapeHtml(c)}</td>`).join('')}
        </tr>
      `;
    });
    
    tableHtml += `</tbody></table>`;
    return tableHtml;
  });
  
  // Headers - Handle both # and *** style headings
  html = html.replace(/^### (.+)$/gim, '<h3 style="color: #1e40af; font-size: 16px; font-weight: 600; margin: 16px 0 8px 0;">$1</h3>');
  html = html.replace(/^## (.+)$/gim, '<h2 style="color: #1e40af; font-size: 18px; font-weight: 700; margin: 20px 0 10px 0;">$1</h2>');
  html = html.replace(/^# (.+)$/gim, '<h1 style="color: #1e40af; font-size: 22px; font-weight: 700; margin: 24px 0 12px 0;">$1</h1>');
  
  // Handle asterisk-based headings
  html = html.replace(/^\*{3}(.+?)\*{3}$/gim, '<h1 style="color: #1e40af; font-size: 22px; font-weight: 700; margin: 24px 0 12px 0;">$1</h1>');
  html = html.replace(/^\*{2}(.+?)\*{2}$/gim, '<h2 style="color: #1e40af; font-size: 18px; font-weight: 700; margin: 20px 0 10px 0;">$1</h2>');
  html = html.replace(/^\*(.+?)\*$/gim, '<h3 style="color: #1e40af; font-size: 16px; font-weight: 600; margin: 16px 0 8px 0;">$1</h3>');
  
  // Bold and italic (but avoid interfering with asterisk headings)
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>');
  // Skip italic replacement to avoid conflicts with asterisk headings
  // html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
  
  // Lists
  html = html.replace(/^[-*] (.+)$/gim, '<li style="margin: 4px 0; margin-left: 20px;">$1</li>');
  html = html.replace(/^\d+\. (.+)$/gim, '<li style="margin: 4px 0; margin-left: 20px;">$1</li>');
  
  // Paragraphs
  html = html.replace(/\n\n+/g, '</p><p style="margin: 12px 0;">');
  html = html.replace(/\n/g, '<br>');
  
  if (!html.startsWith('<')) {
    html = '<p style="margin: 12px 0;">' + html + '</p>';
  }
  
  // Restore code blocks
  codeBlocks.forEach((code, index) => {
    html = html.replace(`___CODE_BLOCK_${index}___`, code);
  });
  
  inlineCodes.forEach((code, index) => {
    html = html.replace(`___INLINE_CODE_${index}___`, code);
  });
  
  return html;
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
